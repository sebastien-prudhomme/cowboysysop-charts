# Default values for jitsi-meet.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

etherpad:
  # Enable shared document editing with Etherpad
  enabled: false

  replicaCount: 1

  image:
    repository: jitsi/etherpad
    tag: 4384-1
    pullPolicy: IfNotPresent

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  # Additional pod annotations (etherpad component)
  podAnnotations: {}

  # Additional pod labels (etherpad component)
  podLabels: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 9001

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 512Mi
    # requests:
    #   cpu: 50m
    #   memory: 256Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

jibri:
  # Enable recording or streaming with Jibri
  enabled: false

  replicaCount: 1

  image:
    repository: jitsi/jibri
    tag: 4384-1
    pullPolicy: IfNotPresent

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  # Additional pod annotations (jibri component)
  podAnnotations: {}

  # Additional pod labels (jibri component)
  podLabels: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 512Mi
    # requests:
    #   cpu: 50m
    #   memory: 256Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # XMPP recorder user for Jibri client connections
  recorderUser: recorder

  # XMPP recorder password for Jibri client connections
  recorderPassword: ""

  # XMPP user for Jibri client connections
  xmppUser: jibri

  # XMPP password for Jibri client connections
  xmppPassword: ""

  # MUC name for the Jibri pool
  breweryMuc: jibribrewery

  # MUC connection timeout
  pendingTimeout: 90

  # The finalizing script. Will run after recording is complete
  finalizeRecordingScriptPath: /config/finalize.sh

  # Directory for logs inside Jibri container
  logsDir: /config/logs

  # Directory for recordings inside Jibri container
  recordingDir: /config/recordings

  # Prefix domain for strip inside Jibri
  stripDomainJid: muc

  # Name of existing Secret to use (jibri component)
  existingSecret: ""

jicofo:
  replicaCount: 1

  image:
    repository: jitsi/jicofo
    tag: 4384-1
    pullPolicy: IfNotPresent

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  # Additional pod annotations (jicofo component)
  podAnnotations: {}

  # Additional pod labels (jicofo component)
  podLabels: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 8000

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 512Mi
    # requests:
    #   cpu: 50m
    #   memory: 256Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # XMPP component password for Jicofo
  componentSecret: ""

  # XMPP user for Jicofo client connections
  authUser: focus

  # XMPP password for Jicofo client connections
  authPassword: ""

  # Name of existing Secret to use (jicofo component)
  existingSecret: ""

# {{ if and .Env.JIGASI_SIP_URI .Env.JIGASI_BREWERY_MUC }}
# org.jitsi.jicofo.jigasi.BREWERY={{ .Env.JIGASI_BREWERY_MUC}}
# {{ end }}

# {{ if .Env.ENABLE_AUTH | default "0" | toBool }}
# {{ end }}

# {{ if .Env.JICOFO_RESERVATION_REST_BASE_URL }}
# {{ end }}

jigasi:
  # XMPP user for Jigasi MUC client connections
  xmppUser: jigasi

  # XMPP password for Jigasi MUC client connections
  xmppPassword: ""

  # Name of existing Secret to use (jigasi component)
  existingSecret: ""


# # SIP account
# {{ if and .Env.JIGASI_SIP_PORT .Env.JIGASI_SIP_TRANSPORT }}
# net.java.sip.communicator.impl.protocol.sip.acc1.PROXY_ADDRESS={{ .Env.JIGASI_SIP_SERVER }}
# net.java.sip.communicator.impl.protocol.sip.acc1.PROXY_AUTO_CONFIG=false
# net.java.sip.communicator.impl.protocol.sip.acc1.PROXY_PORT={{ .Env.JIGASI_SIP_PORT | default "5060" }}
# net.java.sip.communicator.impl.protocol.sip.acc1.PREFERRED_TRANSPORT={{ .Env.JIGASI_SIP_TRANSPORT | default "UDP" }}
# {{ end }}
# {{ if .Env.JIGASI_ENABLE_SDES_SRTP | default "0" | toBool }}
# net.java.sip.communicator.impl.protocol.sip.acc1.SDES_CIPHER_SUITES=AES_CM_128_HMAC_SHA1_80,AES_CM_128_HMAC_SHA1_32
# {{ end }}
# net.java.sip.communicator.impl.protocol.sip.acc1.ACCOUNT_UID=SIP\:{{ .Env.JIGASI_SIP_URI }}
# net.java.sip.communicator.impl.protocol.sip.acc1.PASSWORD={{ .Env.JIGASI_SIP_PASSWORD | b64enc }}
# net.java.sip.communicator.impl.protocol.sip.acc1.PROTOCOL_NAME=SIP
# net.java.sip.communicator.impl.protocol.sip.acc1.SERVER_ADDRESS={{ .Env.JIGASI_SIP_SERVER }}
# net.java.sip.communicator.impl.protocol.sip.acc1.USER_ID={{ .Env.JIGASI_SIP_URI }}
# net.java.sip.communicator.impl.protocol.sip.acc1.KEEP_ALIVE_INTERVAL=25
# net.java.sip.communicator.impl.protocol.sip.acc1.KEEP_ALIVE_METHOD={{ .Env.JIGASI_SIP_KEEP_ALIVE_METHOD | default "OPTIONS" }}
# net.java.sip.communicator.impl.protocol.sip.acc1.DOMAIN_BASE={{ .Env.XMPP_DOMAIN }}

# # XMPP account used for control
# net.java.sip.communicator.impl.protocol.jabber.acc1=acc1
# net.java.sip.communicator.impl.protocol.jabber.acc1.ACCOUNT_UID=Jabber:{{ .Env.JIGASI_XMPP_USER }}@{{ .Env.XMPP_AUTH_DOMAIN }}
# net.java.sip.communicator.impl.protocol.jabber.acc1.USER_ID={{ .Env.JIGASI_XMPP_USER }}@{{ .Env.XMPP_AUTH_DOMAIN }}
# net.java.sip.communicator.impl.protocol.jabber.acc1.IS_SERVER_OVERRIDDEN=true
# net.java.sip.communicator.impl.protocol.jabber.acc1.SERVER_ADDRESS={{ .Env.XMPP_SERVER }}
# net.java.sip.communicator.impl.protocol.jabber.acc1.PASSWORD={{ .Env.JIGASI_XMPP_PASSWORD | b64enc }}
# net.java.sip.communicator.impl.protocol.jabber.acc1.AUTO_GENERATE_RESOURCE=true
# net.java.sip.communicator.impl.protocol.jabber.acc1.BREWERY={{ .Env.JIGASI_BREWERY_MUC }}@{{ .Env.XMPP_INTERNAL_MUC_DOMAIN }}
# net.java.sip.communicator.impl.protocol.jabber.acc1.DOMAIN_BASE={{ .Env.XMPP_DOMAIN }}


# org.jitsi.jigasi.HEALTH_CHECK_SIP_URI={{ .Env.JIGASI_HEALTH_CHECK_SIP_URI | default "" }}
# org.jitsi.jigasi.HEALTH_CHECK_INTERVAL={{ .Env.JIGASI_HEALTH_CHECK_INTERVAL | default "300000" }}

# org.jitsi.jigasi.xmpp.acc.IS_SERVER_OVERRIDDEN=true
# org.jitsi.jigasi.xmpp.acc.SERVER_ADDRESS={{ .Env.XMPP_SERVER }}

# {{ if .Env.ENABLE_AUTH | default "0" | toBool }}
# org.jitsi.jigasi.xmpp.acc.USER_ID={{ .Env.JIGASI_XMPP_USER }}@{{ .Env.XMPP_AUTH_DOMAIN }}
# org.jitsi.jigasi.xmpp.acc.PASS={{ .Env.JIGASI_XMPP_PASSWORD }}
# {{ end }}


# {{ if .Env.ENABLE_TRANSCRIPTIONS | default "0" | toBool }}
# # Transcription config

# org.jitsi.jigasi.transcription.BASE_URL={{ .Env.PUBLIC_URL }}/transcripts
# org.jitsi.jigasi.transcription.jetty.port=-1
# org.jitsi.jigasi.transcription.ADVERTISE_URL={{ .Env.JIGASI_TRANSCRIBER_ADVERTISE_URL | default "false"}}

# org.jitsi.jigasi.transcription.SEND_TXT={{ .Env.JIGASI_TRANSCRIBER_SEND_TXT | default "false"}}
# org.jitsi.jigasi.transcription.RECORD_AUDIO={{ .Env.JIGASI_TRANSCRIBER_RECORD_AUDIO | default "false"}}
# {{end}}






# if [[ -z $JIGASI_XMPP_PASSWORD ]]; then
#     echo 'FATAL ERROR: Jigasi auth password must be set'
#     exit 1
# fi

# # Create Google Cloud Credentials
# if [[ $ENABLE_TRANSCRIPTIONS -eq 1 || $ENABLE_TRANSCRIPTIONS == "true" ]] && [[ ! -f /config/key.json ]]; then
#     if [[ -z $GC_PROJECT_ID || -z $GC_PRIVATE_KEY_ID || -z $GC_PRIVATE_KEY || -z $GC_CLIENT_EMAIL || -z $GC_CLIENT_ID || -z $GC_CLIENT_CERT_URL ]]; then
#         echo 'Transcriptions: One or more environment variables are undefined'
#         exit 1
#     fi

#     jq -n \
#         --arg GC_PROJECT_ID "$GC_PROJECT_ID" \
#         --arg GC_PRIVATE_KEY_ID "$GC_PRIVATE_KEY_ID" \
#         --arg GC_PRIVATE_KEY "$GC_PRIVATE_KEY" \
#         --arg GC_CLIENT_EMAIL "$GC_CLIENT_EMAIL" \
#         --arg GC_CLIENT_ID "$GC_CLIENT_ID" \
#         --arg GC_CLIENT_CERT_URL "$GC_CLIENT_CERT_URL" \
#         '{
#             type: "service_account",
#             project_id: $GC_PROJECT_ID,
#             private_key_id: $GC_PRIVATE_KEY_ID,
#             private_key: $GC_PRIVATE_KEY,
#             client_email: $GC_CLIENT_EMAIL,
#             client_id: $GC_CLIENT_ID,
#             auth_uri: "https://accounts.google.com/o/oauth2/auth",
#             token_uri: "https://oauth2.googleapis.com/token",
#             auth_provider_x509_cert_url: "https://www.googleapis.com/oauth2/v1/certs",
#             client_x509_cert_url: $GC_CLIENT_CERT_URL
#         }' \
#         > /config/key.json
# fi



# JAVA_SYS_PROPS="-Djava.util.logging.config.file=/config/logging.properties"

# DAEMON=/usr/share/jigasi/jigasi.sh
# DAEMON_OPTS="--nocomponent=true --configdir=/ --configdirname=config --min-port=$JIGASI_PORT_MIN --max-port=$JIGASI_PORT_MAX"

# exec s6-setuidgid jigasi /bin/bash -c "JAVA_SYS_PROPS=\"$JAVA_SYS_PROPS\" exec $DAEMON $DAEMON_OPTS"


jvb:
  replicaCount: 1

  image:
    repository: jitsi/jvb
    tag: 4384-1
    pullPolicy: IfNotPresent

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  # Additional pod annotations (jvb component)
  podAnnotations: {}

  # Additional pod labels (jvb component)
  podLabels: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 1024Mi
    # requests:
    #   cpu: 50m
    #   memory: 512Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # XMPP user for JVB MUC client connections
  authUser: jvb

  # XMPP password for JVB MUC client connections
  authPassword: ""

  # Name of existing Secret to use (jvb component)
  existingSecret: ""

  # MUC name for the JVB pool
  breweryMuc: jvbbrewery


# org.jitsi.videobridge.SINGLE_PORT_HARVESTER_PORT={{ .Env.JVB_PORT }}
# org.jitsi.videobridge.DISABLE_TCP_HARVESTER={{ .Env.JVB_TCP_HARVESTER_DISABLED }}
# org.jitsi.videobridge.TCP_HARVESTER_PORT={{ .Env.JVB_TCP_PORT }}
# {{ if .Env.JVB_STUN_SERVERS }}
# org.ice4j.ice.harvest.STUN_MAPPING_HARVESTER_ADDRESSES={{ .Env.JVB_STUN_SERVERS }}
# {{ end }}

# org.jitsi.videobridge.xmpp.user.shard.MUC_NICKNAME={{ .Env.HOSTNAME }}



# JAVA_SYS_PROPS="-Dnet.java.sip.communicator.SC_HOME_DIR_LOCATION=/ -Dnet.java.sip.communicator.SC_HOME_DIR_NAME=config -Djava.util.logging.config.file=/config/logging.properties"

# if [[ ! -z "$DOCKER_HOST_ADDRESS" ]]; then
#     LOCAL_ADDRESS=$(hostname -I | cut -d " " -f1)
#     JAVA_SYS_PROPS="$JAVA_SYS_PROPS -Dorg.ice4j.ice.harvest.NAT_HARVESTER_LOCAL_ADDRESS=$LOCAL_ADDRESS -Dorg.ice4j.ice.harvest.NAT_HARVESTER_PUBLIC_ADDRESS=$DOCKER_HOST_ADDRESS"
# fi

# DEFAULT_DAEMON_OPTS="none"

# DAEMON_OPTS=${JVB_ENABLE_APIS:=$DEFAULT_DAEMON_OPTS}

# exec s6-setuidgid jvb /bin/bash -c "JAVA_SYS_PROPS=\"$JAVA_SYS_PROPS\" exec $DAEMON --apis=${DAEMON_OPTS}"

  metrics:
    service:
      type: ClusterIP
      port: 8942

prosody:
  replicaCount: 1

  image:
    repository: jitsi/prosody
    tag: 4384-1
    pullPolicy: IfNotPresent

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  # Additional pod annotations (prosody component)
  podAnnotations: {}

  # Additional pod labels (prosody component)
  podLabels: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    xmppClientPort: 5222
    xmppServerPort: 5269
    httpPort: 5280
    componentPort: 5347

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 1024Mi
    # requests:
    #   cpu: 50m
    #   memory: 512Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  #globalModules: prometheus

  metrics:
    service:
      type: ClusterIP
      port: 8943

# {{ $ENABLE_AUTH := .Env.ENABLE_AUTH | default "0" | toBool }}
# {{ $AUTH_TYPE := .Env.AUTH_TYPE | default "internal" }}
# {{ $JWT_ASAP_KEYSERVER := .Env.JWT_ASAP_KEYSERVER | default "" }}
# {{ $JWT_ALLOW_EMPTY := .Env.JWT_ALLOW_EMPTY | default "0" | toBool }}
# {{ $JWT_AUTH_TYPE := .Env.JWT_AUTH_TYPE | default "token" }}
# {{ $JWT_TOKEN_AUTH_MODULE := .Env.JWT_TOKEN_AUTH_MODULE | default "token_verification" }}

# {{ if and $ENABLE_AUTH (eq $AUTH_TYPE "jwt") .Env.JWT_ACCEPTED_ISSUERS }}
# asap_accepted_issuers = { "{{ join "\",\"" (splitList "," .Env.JWT_ACCEPTED_ISSUERS) }}" }
# {{ end }}

# {{ if and $ENABLE_AUTH (eq $AUTH_TYPE "jwt") .Env.JWT_ACCEPTED_AUDIENCES }}
# asap_accepted_audiences = { "{{ join "\",\"" (splitList "," .Env.JWT_ACCEPTED_AUDIENCES) }}" }
# {{ end }}

# {{ if $ENABLE_AUTH }}
#   {{ if eq $AUTH_TYPE "jwt" }}
#     authentication = "{{ $JWT_AUTH_TYPE }}"
#     app_id = "{{ .Env.JWT_APP_ID }}"
#     app_secret = "{{ .Env.JWT_APP_SECRET }}"
#     allow_empty_token = {{ if $JWT_ALLOW_EMPTY }}true{{ else }}false{{ end }}
#     {{ if $JWT_ASAP_KEYSERVER }}
#     asap_key_server = "{{ .Env.JWT_ASAP_KEYSERVER }}"
#     {{ end }}

#     {{ else if eq $AUTH_TYPE "ldap" }}
#     authentication = "cyrus"
#     cyrus_application_name = "xmpp"
#     allow_unencrypted_plain_auth = true
#   {{ else if eq $AUTH_TYPE "internal" }}
#     authentication = "internal_plain"
#   {{ end }}
# {{ else }}
#     authentication = "anonymous"
# {{ end }}

#     modules_enabled = {

#         {{ if .Env.XMPP_MODULES }}
#         "{{ join "\";\n\"" (splitList "," .Env.XMPP_MODULES) }}";
#         {{ end }}
#     }

#     c2s_require_encryption = false

# {{ if and $ENABLE_AUTH (.Env.ENABLE_GUESTS | default "0" | toBool) }}
# VirtualHost "{{ .Env.XMPP_GUEST_DOMAIN }}"
#     authentication = "anonymous"
#     c2s_require_encryption = false
# {{ end }}




# {{ $LOG_LEVEL := .Env.LOG_LEVEL | default "info" }}


# -- Enable use of libevent for better performance under high load
# -- For more information see: http://prosody.im/doc/libevent
# --use_libevent = true;

# -- This is the list of modules Prosody will load on startup.
# -- It looks for mod_modulename.lua in the plugins folder, so make sure that exists too.
# -- Documentation on modules can be found at: http://prosody.im/doc/modules
# modules_enabled = {
#         {{ if .Env.GLOBAL_MODULES }}
#         "{{ join "\";\n\"" (splitList "," .Env.GLOBAL_MODULES) }}";
#         {{ end }}
# };

# {{ if .Env.GLOBAL_CONFIG }}
# {{ join "\n" (splitList "\\n" .Env.GLOBAL_CONFIG) }}
# {{ end }}

# {{ if eq (.Env.AUTH_TYPE | default "internal") "ldap" }}
# ldap_servers: {{ .Env.LDAP_URL }}
# ldap_search_base: {{ .Env.LDAP_BASE }}
# {{ if .Env.LDAP_BINDDN | default "" }}
# ldap_bind_dn: {{ .Env.LDAP_BINDDN }}
# ldap_bind_pw: {{ .Env.LDAP_BINDPW }}
# {{ end }}
# ldap_filter: {{ .Env.LDAP_FILTER | default "uid=%u" }}
# ldap_version: {{ .Env.LDAP_VERSION | default "3" }}
# ldap_auth_method: {{ .Env.LDAP_AUTH_METHOD | default "bind" }}
#   {{ if .Env.LDAP_USE_TLS | default "0" | toBool }}
# ldap_tls_key: /config/certs/{{ .Env.XMPP_DOMAIN }}.key
# ldap_tls_cert: /config/certs/{{ .Env.XMPP_DOMAIN }}.crt
#     {{ if .Env.LDAP_TLS_CHECK_PEER | default "0" | toBool }}
# ldap_tls_check_peer: yes
# ldap_tls_cacert_file: {{ .Env.LDAP_TLS_CACERT_FILE | default "/etc/ssl/certs/ca-certificates.crt" }}
# ldap_tls_cacert_dir: {{ .Env.LDAP_TLS_CACERT_DIR | default "/etc/ssl/certs" }}
#     {{ end }}
#     {{ if .Env.LDAP_TLS_CIPHERS }}
# ldap_tls_ciphers: {{ .Env.LDAP_TLS_CIPHERS }}
#     {{ end }}
#   {{ end }}
# {{ end }}
# {{ if .Env.LDAP_START_TLS | default "0" | toBool }}
# ldap_start_tls: yes
# {{ end }}

xmpp:
  # Internal XMPP domain
  domain: meet.jitsi

  # Internal XMPP domain for authenticated services
  authDomain: auth.meet.jitsi

  # XMPP domain for the internal MUC
  internalMucDomain: internal-muc.meet.jitsi

  # Custom Prosody modules for internal MUC component (comma separated)
  internalMucModules: ""

  # XMPP domain for the MUC
  mucDomain: muc.meet.jitsi

  # Custom Prosody modules for MUC component (comma separated)
  mucModules: ""

  # Domain for the jibri recorder
  recorderDomain: recorder.meet.jitsi

web:
  replicaCount: 1

  image:
    repository: jitsi/web
    tag: 4384-1
    pullPolicy: IfNotPresent

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name:

  # Additional pod annotations (web component)
  podAnnotations: {}

  # Additional pod labels (web component)
  podLabels: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 80

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 200m
    #   memory: 1024Mi
    # requests:
    #   cpu: 50m
    #   memory: 512Mi

  nodeSelector: {}

  tolerations: []

  affinity: {}

  # Public URL for the web service
  publicUrl: https://jitsi-meet.local

# 	{{ if .Env.ENABLE_HTTP_REDIRECT | default "0" | toBool }}

# {{ if not (.Env.DISABLE_HTTPS | default "0" | toBool) }}

# }

# # ssl certs
# {{ if .Env.ENABLE_LETSENCRYPT | default "0" | toBool }}
# ssl_certificate /etc/letsencrypt/live/{{ .Env.LETSENCRYPT_DOMAIN }}/fullchain.pem;
# ssl_certificate_key /etc/letsencrypt/live/{{ .Env.LETSENCRYPT_DOMAIN }}/privkey.pem;
# {{ else }}
# ssl_certificate /config/keys/cert.crt;
# ssl_certificate_key /config/keys/cert.key;
# {{ end }}

# #!/usr/bin/with-contenv bash

# # generate keys (maybe)
# if [[ $DISABLE_HTTPS -ne 1 ]]; then
#     if [[ $ENABLE_LETSENCRYPT -eq 1 ]]; then
#         if [[ ! -f /etc/letsencrypt/live/$LETSENCRYPT_DOMAIN/fullchain.pem ]]; then
#             if ! certbot certonly \
#                   --noninteractive \
#                   --standalone \
#                   --preferred-challenges http \
#                   -d $LETSENCRYPT_DOMAIN \
#                   --agree-tos \
#                   --email $LETSENCRYPT_EMAIL ; then
#             fi
#         fi
#     else
#         # use self-signed certs
#     fi
# fi

# if [[ ! -f /config/config.js ]]; then
#     cp /defaults/config.js /config/config.js
#     sed -i \
#         -e "s#// focusUserJid:.*#focusUserJid: '${JICOFO_AUTH_USER}@${XMPP_AUTH_DOMAIN}',#" \
#         /config/config.js

#     if [[ $ENABLE_AUTH -eq 1 ]]; then
#         if [[ $ENABLE_GUESTS -eq 1 ]]; then
#             sed -i \
#                 -e "s#// anonymousdomain:.*#anonymousdomain: '${XMPP_GUEST_DOMAIN}',#" \
#                 /config/config.js
#         fi
#     fi


#     if [[ $ENABLE_TRANSCRIPTIONS -eq 1 || "$ENABLE_TRANSCRIPTIONS" == "true" ]]; then
#         sed -i \
#              -e "s#// transcribingEnabled:.*#transcribingEnabled: true,#" \
#              /config/config.js
#     fi
# fi

# if [[ $DISABLE_HTTPS -ne 1 ]]; then
#     if [[ $ENABLE_LETSENCRYPT -eq 1 ]]; then
#       exec cron -f
#     fi
# fi
